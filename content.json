{"meta":{"title":"Kn's Blog","subtitle":null,"description":null,"author":"Kn","url":"http://mozhukn.gitee.io/mozhukn","root":"/mozhukn/"},"pages":[{"title":"All tags","date":"2019-08-06T07:32:19.000Z","updated":"2019-08-06T07:47:15.415Z","comments":true,"path":"tags/index.html","permalink":"http://mozhukn.gitee.io/mozhukn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"初识SpringCloud|第四篇|Hystrix","slug":"初识SpringCloud-第四篇","date":"2019-08-05T03:25:04.000Z","updated":"2019-08-07T09:42:12.209Z","comments":true,"path":"2019/08/05/初识SpringCloud-第四篇/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/08/05/初识SpringCloud-第四篇/","excerpt":"​ 在微服务架构中，业务被分为一个个微小的服务，服务和服务之间可以相互调用(RPC)，为保证高可用性，单个服务通常会集群部署，由于网络或者其他众多原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会陷入线程阻塞的状态，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。为了解决这个问题，业界提出了”断路器”模型。","text":"​ 在微服务架构中，业务被分为一个个微小的服务，服务和服务之间可以相互调用(RPC)，为保证高可用性，单个服务通常会集群部署，由于网络或者其他众多原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会陷入线程阻塞的状态，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。为了解决这个问题，业界提出了”断路器”模型。 断路器简介12Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls. ----摘自官网 ​ Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图： ​ 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 准备工作​ 这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动eureka-client工程，它的端口为8763。 在Ribbon使用熔断器​ 改进eureka-ribbon工程，在pom文件中加入Hystrix依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; ​ 工程启动类Application上添加注解@EnableHystrix注解开启Hystrix。 123456789101112131415@EnableEurekaClient@SpringBootApplication@EnableHystrixpublic class EurekaRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; ​ 改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi”+name+”error”;，代码如下： 123456789101112131415@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"hiError\") public String hiService(String name) &#123; return restTemplate.getForObject(\"http://EUREKA-CLIENT/hi?name=\"+name,String.class); &#125; public String hiError(String name)&#123; return \"hi \"+name+\" error\"; &#125;&#125; ​ 启动 eureka-ribbon 工程，当我们访问http://localhost:8764/hi?name=kn,浏览器显示： 1hi kn,i am from port:8763 ​ 此时关闭 eureka-client工程，当我们再访问http://localhost:8764/hi?name=forezp，浏览器会显示： 1hi kn error ​ 这就说明当 eureka-client 工程不可用的时候，eureka-ribbon调用 eureka-client的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞。 Feign中使用断路器​ Feign是自带断路器的，在D版本的Spring Cloud之后，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码： 123feign: hystrix: enabled: true ​ 这里我输入hystrix，自动的输出了： 123hystrix: metrics: enabled: true ​ 这导致了我的第一次运行失败。hystrix.metrics.enabled是属于SpringCloud-Hystrix的属性而我这里使用的是Feign客户端，所以应该启用feign.hystrix.enabled的属性。 ​ 对eureka-feign进行改造，只需要在FeignClient的FeignServiceClient接口的注解中加上fallback的指定类就行了： 12345@FeignClient(value = \"eureka-client\",fallback = FeignServerHystrix.class)public interface FeignServiceClient &#123; @GetMapping( \"/hi\") String sayHiFromClientOne(@RequestParam(value = \"name\") String name);&#125; ​ FeignServerHystrix需要实现FeignServiceClient接口并加入容器中： 1234567@Componentpublic class FeignServerHystrix implements FeignServiceClient &#123; @Override public String sayHiFromClientOne(String name) &#123; return \"sorry,error,\"+name; &#125;&#125; ​ 启动eureka-sevice，启动eureka-client，启动eureka-feign，在浏览器输入http://localhost:8765/hi?name=kn，会显示： 1hi kn,i am from port:8763 ​ 停掉eureka-client服务，再次访问，浏览器会出现： 1sorry,error,kn ​ 这说明断路器起到了作用。 结尾​ feign开启熔断之后，FeignServerHystrix会要重写接口的所有方法，而Ribbon似乎更加灵活，只需要在注解上增加fallbackmethod指定方法即可，现在看来两者各有好处。一步步的解决Bug运行成功时令人开心的，还式要继续努力啊。 ​ 最后附上大牛原文链接：http://blog.csdn.net/forezp/article/details/81040990","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://mozhukn.gitee.io/mozhukn/tags/springcloud/"},{"name":"hystrix","slug":"hystrix","permalink":"http://mozhukn.gitee.io/mozhukn/tags/hystrix/"}]},{"title":"初识SpringCloud|第三篇|Feign","slug":"初识SpringCloud-第三篇","date":"2019-08-05T03:22:51.000Z","updated":"2019-08-07T09:41:55.958Z","comments":true,"path":"2019/08/05/初识SpringCloud-第三篇/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/08/05/初识SpringCloud-第三篇/","excerpt":"​ 服务消费者还有一种落地实现是Feign，Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果，并且整合了Hystrix，具有熔断的能力。","text":"​ 服务消费者还有一种落地实现是Feign，Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果，并且整合了Hystrix，具有熔断的能力。 创建Feign服务​ 新建一个SpringBoot模块，取名：eureka-feign，过程同前两篇，pom文件依旧继承父类并引入Feign依赖spring-cloud-starter-feign、Eureka依赖spring-cloud-starter-netflix-eureka-client、Web依赖spring-boot-starter-web，代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;eureka-feign&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-feign&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ application.yml的注册地址依然是http://localhost:8761/eureka/，端口号为 8765，具体代码如下： 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8765spring: application: name: eureka-feign ​ 在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能： 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class EurekaFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaFeignApplication.class, args); &#125;&#125; ​ 定义一个Feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务（声明式调用）。比如在代码中调用了eureka-service服务的“/hi”接口，代码如下： 12345678910/** * @ClassName: FeignServiceClient * @Description TODO: 调用EurekaClient的服务，Feign采用声明式调用， * 且接口会利用动态代理实现（类似于JPA） */@FeignClient(value = \"eureka-client\")public interface FeignServiceClient &#123; @GetMapping( \"/hi\") String sayHiFromClientOne(@RequestParam(value = \"name\") String name);&#125; ​ 写一个Controller类进行测试，对外暴露一个”/hi”的API接口，调用Feign客户端的FeignServiceClient来消费服务。 12345678910@RestControllerpublic class HiController &#123; @Autowired FeignServiceClient feignServiceClient; @GetMapping(\"/hi\") public String sayHi(@RequestParam String name) &#123; return feignServiceClient.sayHiFromClientOne( name ); &#125;&#125; 启动服务 启动 eureka-server，端口为 8761 启动 eureka-client，端口为 8762，8763 启动 eureka-feign，端口为 8765 在浏览器多次访问http://localhost:8765/hi?name=kn,浏览器会交替显示： 12hi kn,i am from port:8762hi kn,i am from port:8763 结尾​ 这一篇的操作并没有遇到什么问题，根据Fegin的使用情况比较rest+Ribbon，总体感觉上Feign的声明式调用操作起来更加舒服。大牛的原文链接地址：http://blog.csdn.net/forezp/article/details/81040965","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://mozhukn.gitee.io/mozhukn/tags/springcloud/"},{"name":"feign","slug":"feign","permalink":"http://mozhukn.gitee.io/mozhukn/tags/feign/"}]},{"title":"初识SpringCloud|第二篇|Ribbon","slug":"初识SpringCloud-第二篇","date":"2019-08-04T02:50:21.000Z","updated":"2019-08-07T09:41:38.922Z","comments":true,"path":"2019/08/04/初识SpringCloud-第二篇/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/08/04/初识SpringCloud-第二篇/","excerpt":"​ 在微服务架构中，业务被拆分成一个个独立的服务，各个服务之间一般通过Restful Api进行通讯。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。","text":"​ 在微服务架构中，业务被拆分成一个个独立的服务，各个服务之间一般通过Restful Api进行通讯。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。 Ribbon简介12Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.-----摘自官网 ​ ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。而Feign默认集成了ribbon。 准备工作​ 因为是基于第一篇的，所以需要启动eureka-sever和eureka-client工程，因为测试Ribbon，所以启动两个服务提供者，将eureka-client工程配置文件中的端口号由8762改成8763再启动工程，这个时候会发现在eureka-server中注册了两个服务，这就相当于一个小的集群。 ​ 需要注意的是，idea，是不能直接修改了yml文件之后就启动多个实例的，会出现如下提醒： ​ idea需要在工程edit configuration设置勾选Allow paraller run(我的idea版本是2019.1.3，有的版本是要将将默认的Single instance only(单实例)的钩去掉。) ​ 服务消费者​ 重新建立一个springboot模块，取名eureka-ribbon，流程基本同上，pom文件依旧继承父pom,与yml的配置如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;eureka-ribbon&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka_ribbon&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ 在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。 123456789101112131415@EnableEurekaClient//@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; ​ 这里说一下@EnableEurekaClient和@EnableDiscoveryClient的区别： @EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现； @EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用； 简单的来说就是@EnableEurekaClient只适用于eureka作为注册中心的，而@EnableDiscoveryClient也适用其他注册中心的落地实现如consul等。 写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-client服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下： 1234567891011@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; public String hiService(String name) &#123; return restTemplate.getForObject(\"http://EUREKA-CLIENT/hi?name=\"+name,String.class); &#125;&#125; 1234567891011@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @GetMapping(value = \"/hi\") public String hi(@RequestParam String name) &#123; return helloService.hiService( name ); &#125;&#125; 启动工程,eureka-server界面如下： 在浏览器上多次访问http://localhost:8764/hi?name=kn会重复显示： 12hi kn ,i am from port:8762hi kn ,i am from port:8763 这说明当我们通过调用restTemplate.getForObject(“http://SERVICE-CLIENT/hi?name=”+name,String.class)方法时，已经做了负载均衡，访问了不同的端口的服务实例。 结尾​ 服务实例名称不能以下划线连接否则在消费者调用restTemplate.getForObject()时会报错，现在架构方面是一个服务注册中心eureka-server:8761，两个服务提供者eureka-client:8762和8763，一个服务消费者eureka-ribbon:8764，消费者和服务提供者之间通过rest+ribbon进行通讯。","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://mozhukn.gitee.io/mozhukn/tags/springcloud/"},{"name":"eureka","slug":"eureka","permalink":"http://mozhukn.gitee.io/mozhukn/tags/eureka/"},{"name":"ribbon","slug":"ribbon","permalink":"http://mozhukn.gitee.io/mozhukn/tags/ribbon/"}]},{"title":"初识SpringCloud|第一篇|Eureka","slug":"初识SpringCloud-第一篇","date":"2019-08-03T02:12:10.000Z","updated":"2019-08-07T09:42:34.056Z","comments":true,"path":"2019/08/03/初识SpringCloud-第一篇/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/08/03/初识SpringCloud-第一篇/","excerpt":"​ SpringCloud是微服务的一站式解决方案，为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。 ​ 关于微服务一直只是观看过一些资料有一些了解，还没真正动手过，观看和学习了CSDN大牛方志朋的SpringCloud教程博客之后才有的这一次Demo。本次SpringBoot的版本为2.0.3.RELEASE，SpringCloud的版本为 Finchley.RELEASE。","text":"​ SpringCloud是微服务的一站式解决方案，为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。 ​ 关于微服务一直只是观看过一些资料有一些了解，还没真正动手过，观看和学习了CSDN大牛方志朋的SpringCloud教程博客之后才有的这一次Demo。本次SpringBoot的版本为2.0.3.RELEASE，SpringCloud的版本为 Finchley.RELEASE。 主工程​ 使用Maven作为主工程，在pom文件中引入相对应的依赖。其他module工程全部继承此父类pom。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;springcloud&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ###服务注册中心 ​ 右键工程，新建module，直接使用spring initializr创建工程，依赖选中Spring Cloud Discovery中的 Eureka server即可，如图。 ​ ​ 将pom文件修改成继承父pom，并加入spring-cloud-starter-netflix-eureka-server依赖。 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ 在SpringBoot启动类Application上添加一个注解@EnableEurekaServer，声明这是一个服务注册中心 123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; ​ Eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下Erureka server也是一个Eureka client ,必须要指定一个 server。Eureka server的配置文件appication.yml如下： 123456789101112131415server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #$&#123;eureka.instance.hostname&#125; 设备的主机名spring: application: name: eurka-server ​ 通过声明eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server. 以下为两个配置属性的解释（引用自CSDN博文https://blog.csdn.net/qq_38289534/article/details/82146939） registerWithEureka：是否要注册到其他Server上。如果我的Server上其实开放了一些Http接口供调用，那么就需要注册，这样其他的Client才能发现我的服务，才能通过RPC调用我提供的Http接口。如果我的Server没有提供对外Http接口，那么这个参数可以设置为false。 fetchRegistry：是否需要拉取服务信息。和是否注册一样，如果我的Server需要调用其他的Client的Http接口，那么就需要获取相应的服务发现信息，这样才能正常的调用。同时这个参数还有一个重要的作用，就是决定Server在初始化时是否立即全量同步其他节点的服务信息！！！Server初始化时会先初始化其内置的Client。若配置了fetchRegistry=true，那么Client在初始化时会从其他Server全量拉取服务信息，放进Client容器中。Server在初始化时会尝试同步Client容器里的服务信息，如果fetchRegistry=false，服务信息不存在，只能被动的等其他Server节点以增量的形式同步过来(Client在执行注册和心跳时对应的注册Server节点会广播此事件，同步给其他的Server节点。当其他Server节点还没有此服务信息时，改为注册此服务信息)。当然正常的通过心跳来同步，最多也仅需要30S而已，是否需要设置此参数就看各自的需求了。 启动程序，通过localhost:8761查看eureka server的界面如下： ​ 服务提供者​ client创建过程和server类似，相关配置有所改动。当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。 ​ pom文件配置添加了spring-cloud-starter-netflix-eureka-client和web相关依赖，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;eureka_client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.kn&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ​ 通过在Application启动类上添加@EnableEurekaClient 注解表明是一个eureka server 123456789101112131415161718@RestController@EnableEurekaClient@SpringBootApplicationpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125; @Value(\"$&#123;server.port&#125;\") String port; @RequestMapping(\"/hi\") public String home(@RequestParam(value = \"name\", defaultValue = \"kn\") String name) &#123; return \"hi \" + name + \" ,i am from port:\" + port; &#125;&#125; ​ 在application.yml添加相应的配置。 12345678910server: port: 8762spring: application: name: eureka-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ ​ 需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。启动client工程，打开http://localhost:8761 ，即eureka server 的网址： ​ ​ 我们可以看到一个服务已经注册在服务中了，服务名为eureka-client。这时候在地址栏输入http://localhost:8762/hi?name=kn，会出现 1hi kn ,i am from port:8762 结尾​ 这一篇进行的比较顺利，没有遇到什么问题。最后附上大佬原版的博客链接：https://blog.csdn.net/forezp/article/details/81040925","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://mozhukn.gitee.io/mozhukn/tags/springcloud/"},{"name":"eureka","slug":"eureka","permalink":"http://mozhukn.gitee.io/mozhukn/tags/eureka/"}]},{"title":"SpringBoot配置静态资源映射","slug":"SpringBoot配置静态资源映射","date":"2019-07-26T00:56:43.000Z","updated":"2019-07-27T12:59:39.524Z","comments":true,"path":"2019/07/26/SpringBoot配置静态资源映射/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/07/26/SpringBoot配置静态资源映射/","excerpt":"​ SpringBoot打包成jar项目时，HTML页面和CSS等静态资源得放置目录是由规定的。开发中一些需要上传的资源如图片，通常我们会配置资源映射，将其存放在服务器的某个文件夹下。","text":"​ SpringBoot打包成jar项目时，HTML页面和CSS等静态资源得放置目录是由规定的。开发中一些需要上传的资源如图片，通常我们会配置资源映射，将其存放在服务器的某个文件夹下。 ​ 在SpringBoot中打包成jar项目时，静态页面和css放置的目录有规定。在SpringBoot中相关配置在WebMvcAutoConfiguration接口中。通过这个分析所有/webjars/**都去classpath:/META-INF/resources/webjars/找资源。所谓的webjars是指以jar包的方式引入资源。 ​ 一般通过实现这个接口实现addResourceHandlers方法来设置资源映射，如图所示，springboot常用的static包下的静态文件映射就是这么做的。ResourceHandlerRegistry类负责储存资源文件的注册，将需要添加的请求路径注册进去并为其添加映射路径。（static/**代表所有static下的所有请求） ​ 1234567@Configurationpublic class OisWebMvcConfigurerAdapter implements WebMvcConfigurer&#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;&#125;&#125; ​ 开发时经常会为上传图片做静态资源映射到服务器指定的地方，我们简单的映射到F:/upload/下，如图所示。 123456789101112@Configurationpublic class OisWebMvcConfigurerAdapter implements WebMvcConfigurer&#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/static/**\").addResourceLocations(\"classpath:/static/\"); //图片上传路径 registry.addResourceHandler(\"/upload/**\").addResourceLocations(\"file:F:/upload/\"); WebMvcConfigurer.super.addResourceHandlers(registry); &#125;&#125; ​ 这样我们就能通过upload的请求找到对应的资源了。 ​ 然而不可能就这样将资源映射写死，每一次使用的时候都拼接完整的请求路径，所以我们会在配置文件中设定好路径映射，需要时通过@value将属性赋值使用，如图所示。也能使用@ConfigurationProperties在类上标识直接指定多个属性，就不多演示了。 123#上传的映射uploads: user_img_path: F:/upload/ 12345678910111213@Configurationpublic class OisWebMvcConfigurerAdapter implements WebMvcConfigurer&#123; @Value(\"$&#123;uploads.user_img_path&#125;\") private String user_img_path; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/static/**\").addResourceLocations(\"classpath:/static/\"); //图片上传路径 registry.addResourceHandler(\"/upload/**\").addResourceLocations(\"file:\"+user_img_path); WebMvcConfigurer.super.addResourceHandlers(registry); &#125; 以上只是第一种方式，常用的还有一种在配置文件中通过spring.resources.static-locations直接进行配置，如图。 ​ 1234mvc: static-path-pattern: /upload/** resources: static-locations: classpath:/META- INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,file:/home/upload/ ​ 不能在staic-locations下只配置upload请求的映射，至少也要添加classpath:/static/ 不然存放再这个包下的如css,js的文件会获取不到。 博主水平有限，仍然在学习中，如有不足之处，请帮忙指正，感激不尽。","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://mozhukn.gitee.io/mozhukn/tags/springboot/"}]},{"title":"浅谈SpringBoot整合Shiro","slug":"浅谈SpringBoot整合Shiro","date":"2019-07-14T08:07:00.000Z","updated":"2019-07-14T08:19:35.521Z","comments":true,"path":"2019/07/14/浅谈SpringBoot整合Shiro/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/07/14/浅谈SpringBoot整合Shiro/","excerpt":"​ Shiro是一个简单的安全框架，主要功能有认证，授权，加密，会话管理，Web集成，缓存等。对比起来Spring Security，可能没有Spring Security功能强大，但是在实际工作中并不需要那么复杂的东西，所以简单的Shrio对于我们来说就足够了。 ​ 这一次我们只谈谈简单使用，包括认证和授权，不考虑其源码和深层次的东西。我也只是第一次使用测试，想做个记录，有很多不足之处还望谅解。","text":"​ Shiro是一个简单的安全框架，主要功能有认证，授权，加密，会话管理，Web集成，缓存等。对比起来Spring Security，可能没有Spring Security功能强大，但是在实际工作中并不需要那么复杂的东西，所以简单的Shrio对于我们来说就足够了。 ​ 这一次我们只谈谈简单使用，包括认证和授权，不考虑其源码和深层次的东西。我也只是第一次使用测试，想做个记录，有很多不足之处还望谅解。 环境配置首先我们要进行相对应的环境配置，除了相对应的SpringBoot启动器和Web启动器外，还添加了SpringBoot默认模板引擎Thymeleaf的相应配置，因为我用的是SpringBoot1.5.19的版本而不是2.0所以thymeleaf默认的是2.0版本，thymeleaf-layout默认是1.0，我们需要将thymeleaf版本改成3.0和其thymeleaf相对应的2.0版本，如图所示 ​ 重点是Shiro，使用版本是1.4.0 Shiro配置​ shiro配置主要包含三步: ​ 1.创建ShiroFilterFacoryBean ​ 2.创建DefaultWebSecurityManager ​ 3.创建自定义的Realm类，Shiro会从Realm类中进行认证逻辑和授权逻辑的处理 登陆认证​ shiro登陆认证也是分为三步： ​ 1.通过SecurityUtils获取subject对象 ​ 2.封装当前登陆用户的账号密码 ​ 3.执行登陆方法通过抛出shiro封装好的异常来确定登陆状态 执行登陆认证​ 通过认证出来的token对象取出登陆用户的信息，并判断该用户的状态,如果不存在则直接返回空， shiro抛出用户名不存在的异常，然后直接返回一个AuthenticationInfo的实现类，我们这里直接返回一个SimpleAuthenticationInfo就行了，将从数据库取出来封装了所有相关属性的user和密码返回就行，shirp会帮我们进行密码校验。 执行授权逻辑​ 创建一个SimpleAuthorziationInfo对象，将当前用户的角色以及对应的权限通过addRoles或者addStringPermissions方法加入Info。因为用户角色权限的关系需要根据实际情况来选择，图中给了点示例，可以参考，最后将info对象返回。 shiro标签​ 以上已经完成了简单的权限控制，想在界面更好的优化（比如隐藏相应的资源）可以通过shiro的标签来进行操作，需要导入额外的依赖thymeleaf-extras-shiro，html头文件也需要做相应的声明，以下举例两个简单的shiro标签 写在末尾的话​ 第一次写博客第一次用shiro，不论是技术还是博客都很粗糙，我依然很菜，希望大家学习顺利，成为大牛。","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://mozhukn.gitee.io/mozhukn/tags/springboot/"}]},{"title":"Hexo实现个人技术博客","slug":"Hexo实现个人技术博客","date":"2019-07-14T08:05:02.000Z","updated":"2019-08-05T08:56:23.388Z","comments":true,"path":"2019/07/14/Hexo实现个人技术博客/","link":"","permalink":"http://mozhukn.gitee.io/mozhukn/2019/07/14/Hexo实现个人技术博客/","excerpt":"​ Hexo(中文官方网站)是一个快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。 Hexo支持Github Flavored Markdown的所有功能， 甚至可以整合Octopress的大多数插件。 并自己也拥有强大的插件系统。","text":"​ Hexo(中文官方网站)是一个快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。 Hexo支持Github Flavored Markdown的所有功能， 甚至可以整合Octopress的大多数插件。 并自己也拥有强大的插件系统。 本地调试安装node.js 查看nodejs和npm版本 安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo 1cnpm install -g hexo-cli 验证hexo（hexo -v） 在目录下建立博客文件夹，同时cd进目录 安装git创建架构 1hexo init 开始本地调试 1hexo s 创建博客 1hexo new &quot;我的第一篇博客&quot; 文章会自动生成在/source/_post目录下 清理并生成 hexo clean(clean清除缓存之后要及时生成) 1hexo g ​ 远端部署登陆GitHub并新建仓库 仓库名为”用户名.github.io” 创建 在博客目录下安装git插件 1cnpm install --save hexo-deployer-git ​ 设置_config.yml 在Deployment下的type: 后加上git（注意！type:和git间有一空格） 在type项下一行加 1repo: 仓库链接 下一行加 1branch: master 设置git 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 部署到远端 hexo d主题更换下载zip包解压在themes文件夹下或git clone下来 在博客目录_config.yml中更改主题 1theme: 主题名（默认是landscape） 清理并生成 1hexo clean 1hexo g ​ 后期发文hexo new &quot;博客名&quot; 编辑博文 hexo clean hexo g（生成博客） hexo s（本地测试） hexo d（部署到远端）结语 本文受CodeSheep程序羊视频https://www.bilibili.com/video/av44544186?t=1165启发，主体由羊圈群友编写，稍作改动和增加，有什么问题欢迎交流。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mozhukn.gitee.io/mozhukn/tags/hexo/"}]}]}